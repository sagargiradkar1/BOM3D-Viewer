<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Professional BOM Viewer | Interactive 3D Assembly Explorer</title>
    <style>
      :root {
        --primary-color: #2c3e50;
        --secondary-color: #3498db;
        --accent-color: #e74c3c;
        --success-color: #27ae60;
        --warning-color: #f39c12;
        --background-color: #ecf0f1;
        --sidebar-bg: #ffffff;
        --text-color: #2c3e50;
        --border-color: #bdc3c7;
        --hover-color: #f8f9fa;
        --selected-color: #3498db;
        --shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: var(--background-color);
        overflow: hidden;
        color: var(--text-color);
      }

      .container {
        display: flex;
        height: 100vh;
        position: relative;
      }

      /* Mobile Toggle Button */
      .mobile-toggle {
        display: none;
        position: fixed;
        top: 16px;
        left: 16px;
        z-index: 1001;
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 8px;
        padding: 12px;
        font-size: 18px;
        cursor: pointer;
        box-shadow: var(--shadow);
        touch-action: manipulation;
      }

      .mobile-toggle:hover {
        background: #34495e;
      }

      /* Responsive BOM Panel */
      .bom-panel {
        width: 350px;
        background: var(--sidebar-bg);
        border-right: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        box-shadow: var(--shadow);
        z-index: 100;
        transition: transform 0.3s ease;
      }

      .bom-header {
        background: linear-gradient(
          135deg,
          var(--primary-color) 0%,
          #34495e 100%
        );
        color: white;
        padding: 12px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .bom-header .title-info {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .bom-header .icon {
        font-size: 1.2em;
      }

      .bom-header .title-section h1 {
        font-size: 1.1em;
        font-weight: 600;
        margin-bottom: 2px;
      }

      .bom-header .subtitle {
        opacity: 0.9;
        font-size: 0.75em;
        font-weight: 400;
      }

      .close-btn {
        display: none;
        background: none;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        touch-action: manipulation;
      }

      .close-btn:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .bom-controls {
        padding: 12px 16px;
        border-bottom: 1px solid var(--border-color);
        background: #fafbfc;
      }

      .search-container {
        position: relative;
      }

      .search-box {
        width: 100%;
        padding: 10px 12px 10px 36px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 14px;
        transition: border-color 0.3s ease;
        background: white;
        touch-action: manipulation;
      }

      .search-box:focus {
        outline: none;
        border-color: var(--secondary-color);
        box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
      }

      .search-icon {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #7f8c8d;
        font-size: 14px;
        pointer-events: none;
      }

      .bom-stats {
        display: flex;
        justify-content: space-between;
        margin-top: 8px;
        font-size: 0.7em;
        color: #7f8c8d;
      }

      .bom-tree {
        flex: 1;
        overflow-y: auto;
        padding: 0;
        font-size: 12px;
        -webkit-overflow-scrolling: touch;
      }

      .bom-tree::-webkit-scrollbar {
        width: 4px;
      }

      .bom-tree::-webkit-scrollbar-track {
        background: #f1f1f1;
      }

      .bom-tree::-webkit-scrollbar-thumb {
        background: #c1c1c1;
        border-radius: 2px;
      }

      /* Touch-friendly Hierarchical Tree Styles */
      .tree-node {
        border-bottom: 1px solid #f8f9fa;
        background: white;
      }

      .tree-item {
        display: flex;
        align-items: center;
        padding: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
        min-height: 44px; /* Touch-friendly minimum */
        touch-action: manipulation;
      }

      .tree-item:hover {
        background: var(--hover-color);
      }

      .tree-item.selected {
        background: linear-gradient(90deg, var(--selected-color), #5dade2);
        color: white;
        box-shadow: inset 3px 0 0 var(--accent-color);
      }

      .tree-item.selected .node-icon {
        color: white;
      }

      /* Touch-friendly expand button */
      .expand-button {
        width: 32px;
        height: 32px;
        border: 1px solid #bdc3c7;
        background: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: all 0.2s;
        margin-right: 8px;
        flex-shrink: 0;
        font-size: 12px;
        font-weight: bold;
        color: #7f8c8d;
        touch-action: manipulation;
      }

      .expand-button:hover {
        border-color: var(--secondary-color);
        background: #f8f9fa;
      }

      .expand-button.expanded {
        background: var(--secondary-color);
        color: white;
        border-color: var(--secondary-color);
      }

      .node-icon {
        margin-right: 8px;
        font-size: 14px;
        width: 16px;
        text-align: center;
        flex-shrink: 0;
      }

      .assembly-icon {
        color: #3498db;
      }

      .part-icon {
        color: #e67e22;
      }

      .node-content {
        flex: 1;
        min-width: 0;
      }

      .node-name {
        font-weight: 500;
        font-size: 13px;
        margin-bottom: 2px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .node-details {
        font-size: 10px;
        opacity: 0.7;
        display: flex;
        gap: 8px;
      }

      .tree-item.selected .node-details {
        opacity: 0.9;
      }

      .tree-children {
        display: none;
        background: #fafbfc;
      }

      .tree-children.expanded {
        display: block;
      }

      /* Responsive 3D Viewer Panel */
      .viewer-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: var(--background-color);
        min-width: 0;
      }

      .viewer-header {
        background: white;
        padding: 12px 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        flex-wrap: wrap;
        gap: 12px;
      }

      .viewer-title {
        font-size: 1.2em;
        font-weight: 600;
        color: var(--primary-color);
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .viewer-controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .control-btn {
        padding: 10px 14px;
        background: white;
        color: var(--primary-color);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.8em;
        font-weight: 500;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 4px;
        min-height: 44px; /* Touch-friendly */
        touch-action: manipulation;
      }

      .control-btn:hover {
        background: var(--secondary-color);
        color: white;
        border-color: var(--secondary-color);
      }

      .control-btn.active {
        background: var(--accent-color);
        color: white;
        border-color: var(--accent-color);
      }

      #threejs-container {
        flex: 1;
        position: relative;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        touch-action: none; /* Allow Three.js to handle touch events */
      }

      .loading-spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 200;
      }

      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid var(--secondary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 16px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Professional animations */
      .highlight-animation {
        animation: highlight-pulse 0.8s ease-in-out;
      }

      @keyframes highlight-pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.02);
        }
      }

      .fade-in {
        animation: fadeIn 0.5s ease-in-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Mobile Responsiveness */
      @media (max-width: 768px) {
        .mobile-toggle {
          display: block;
        }

        .bom-panel {
          position: fixed;
          top: 0;
          left: 0;
          width: 90%;
          max-width: 320px;
          height: 100vh;
          transform: translateX(-100%);
          z-index: 1000;
          box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .bom-panel.mobile-visible {
          transform: translateX(0);
        }

        .close-btn {
          display: block;
        }

        .viewer-panel {
          width: 100%;
        }

        .viewer-header {
          padding: 8px 16px;
        }

        .viewer-title {
          font-size: 1em;
        }

        .control-btn {
          padding: 8px 10px;
          font-size: 0.7em;
          min-height: 40px;
          flex-direction: column; /* Stack icon and text vertically */
          gap: 2px;
        }

        .bom-controls {
          padding: 8px 12px;
        }

        .search-box {
          padding: 8px 10px 8px 32px;
          font-size: 16px; /* Prevent zoom on iOS */
        }

        .bom-stats {
          font-size: 0.65em;
          flex-wrap: wrap;
          gap: 4px;
        }

        .tree-item {
          padding: 6px;
          min-height: 40px;
        }

        .expand-button {
          width: 28px;
          height: 28px;
          font-size: 10px;
        }

        .node-name {
          font-size: 12px;
        }

        .node-details {
          font-size: 9px;
        }
      }

      @media (max-width: 480px) {
        .bom-panel {
          width: 95%;
        }

        .viewer-header {
          flex-direction: column;
          align-items: stretch;
          gap: 8px;
        }

        .viewer-controls {
          justify-content: center;
          gap: 6px;
        }

        .control-btn {
          flex: 1;
          justify-content: center;
          padding: 8px;
          font-size: 0.65em;
          min-height: 44px;
        }

        .bom-header .title-section h1 {
          font-size: 1em;
        }

        .bom-header .subtitle {
          font-size: 0.7em;
        }
      }

      /* Tablet Responsiveness */
      @media (min-width: 769px) and (max-width: 1024px) {
        .bom-panel {
          width: 300px;
        }

        .viewer-controls {
          gap: 6px;
        }

        .control-btn {
          padding: 8px 10px;
          font-size: 0.75em;
        }
        .control-btn span:last-child {
          font-size: 0.6em;
        }

        .bom-header .title-section h1 {
          font-size: 1em;
        }

        .bom-header .subtitle {
          font-size: 0.7em;
        }

        .tree-item {
          min-height: 36px;
        }

        .expand-button {
          width: 28px;
          height: 28px;
        }
      }

      /* Large Desktop */
      @media (min-width: 1200px) {
        .bom-panel {
          width: 400px;
        }

        .tree-item {
          padding: 10px;
          min-height: 48px;
        }

        .expand-button {
          width: 36px;
          height: 36px;
          font-size: 14px;
        }

        .node-name {
          font-size: 14px;
        }

        .node-details {
          font-size: 11px;
        }
      }

      /* Touch device improvements */
      @media (hover: none) and (pointer: coarse) {
        .tree-item:hover {
          background: inherit; /* Remove hover on touch devices */
        }

        .tree-item:active {
          background: var(--hover-color);
        }

        .expand-button:hover {
          border-color: #bdc3c7;
          background: white;
        }

        .expand-button:active {
          border-color: var(--secondary-color);
          background: #f8f9fa;
        }

        .control-btn:hover {
          background: white;
          color: var(--primary-color);
          border-color: var(--border-color);
        }

        .control-btn:active {
          background: var(--secondary-color);
          color: white;
          border-color: var(--secondary-color);
        }
      }

      /* Landscape orientation optimizations */
      @media (orientation: landscape) and (max-width: 768px) {
        .bom-panel {
          width: 300px;
        }

        .viewer-header {
          padding: 6px 16px;
        }

        .control-btn {
          padding: 6px 8px;
          font-size: 0.65em;
          min-height: 36px;
        }
      }

      /* Accessibility improvements */
      @media (prefers-reduced-motion: reduce) {
        .tree-item,
        .expand-button,
        .control-btn,
        .bom-panel {
          transition: none;
        }

        .highlight-animation,
        .fade-in {
          animation: none;
        }
      }

      /* High contrast mode support */
      @media (prefers-contrast: high) {
        .tree-item {
          border-bottom: 2px solid var(--border-color);
        }

        .expand-button {
          border-width: 2px;
        }

        .control-btn {
          border-width: 2px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Mobile Toggle Button -->
      <button
        class="mobile-toggle"
        id="mobileToggle"
        aria-label="Toggle BOM Panel"
      >
        üìã
      </button>

      <!-- Responsive BOM Panel -->
      <div class="bom-panel" id="bomPanel">
        <div class="bom-header">
          <div class="title-info">
            <div class="icon">üìã</div>
            <div class="title-section">
              <h1>Assembly Structure</h1>
              <div class="subtitle">Interactive BOM Explorer</div>
            </div>
          </div>
          <button class="close-btn" id="closeBtn" aria-label="Close BOM Panel">
            ‚úï
          </button>
        </div>

        <div class="bom-controls">
          <div class="search-container">
            <div class="search-icon">üîç</div>
            <input
              type="text"
              class="search-box"
              placeholder="Search assemblies and parts..."
              id="searchBox"
              aria-label="Search assemblies and parts"
            />
          </div>
          <div class="bom-stats">
            <span>Assemblies: <strong id="assemblyCount">0</strong></span>
            <span>Parts: <strong id="partCount">0</strong></span>
            <span>Total: <strong id="totalCount">0</strong></span>
          </div>
        </div>

        <div
          class="bom-tree"
          id="bomTree"
          role="tree"
          aria-label="Assembly structure tree"
        >
          <div class="loading-spinner">
            <div class="spinner"></div>
            <div>Loading assembly structure...</div>
          </div>
        </div>
      </div>

      <!-- Enhanced 3D Viewer Panel -->
      <div class="viewer-panel">
        <div class="viewer-header">
          <div class="viewer-title">
            <span>üéØ</span>
            <span>3D Model Viewer</span>
          </div>
          <div class="viewer-controls">
            <button
              class="control-btn"
              onclick="resetCamera()"
              aria-label="Reset camera view"
            >
              <span>üìπ</span> <span>Reset View</span>
            </button>
            <button
              class="control-btn"
              id="wireframeBtn"
              onclick="toggleWireframe()"
              aria-label="Toggle wireframe mode"
            >
              <span>üî≤</span> <span>Wireframe</span>
            </button>
            <button
              class="control-btn"
              id="boundingBoxBtn"
              onclick="toggleBoundingBoxes()"
              aria-label="Toggle bounding boxes"
            >
              <span>üì¶</span> <span>Bounds</span>
            </button>
            <button
              class="control-btn"
              onclick="toggleAutoRotate()"
              aria-label="Toggle auto rotation"
            >
              <span>üîÑ</span> <span>Rotate</span>
            </button>
          </div>
        </div>

        <div id="threejs-container" aria-label="3D model viewer">
          <div class="loading-spinner" id="loadingSpinner">
            <div class="spinner"></div>
            <div>Loading 3D model...</div>
          </div>
        </div>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      class ProfessionalBOMViewer {
        constructor() {
          // Three.js components
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;
          this.model = null;

          // Data management
          this.assemblyData = null;
          this.flattenedParts = new Map();
          this.selectedNodeId = null;
          this.selectedMeshIndex = null;

          // 3D scene management
          this.meshes = [];
          this.originalMaterials = new Map();
          this.boundingBoxHelpers = [];

          // Visual states
          this.isAutoRotating = false;
          this.isWireframe = false;
          this.showBoundingBoxes = false;

          // Mobile specific
          this.isMobile = window.innerWidth <= 768;
          this.bomPanelVisible = !this.isMobile;

          // Materials
          this.highlightMaterial = new THREE.MeshBasicMaterial({
            color: 0xe74c3c,
            transparent: true,
            opacity: 0.8,
          });

          // File paths
          this.modelPaths = [
            "output/web/model.glb",
          ];

          this.bomPaths = [
            "output/bom/bom_data.json"
          ];

          this.init();
        }

        async init() {
          try {
            console.log("Initializing 3D viewer...");
            this.setupMobileControls();
            this.initThreeJS();

            console.log("Loading assembly data...");
            await this.loadAssemblyData();

            console.log("Loading 3D model...");
            await this.loadModel();

            console.log("Building assembly tree...");
            this.buildAssemblyTree();

            this.setupEventListeners();
            this.animate();

            console.log("Ready - Click on parts to explore");
          } catch (error) {
            console.error("Initialization error:", error);
          }
        }

        setupMobileControls() {
          const mobileToggle = document.getElementById("mobileToggle");
          const closeBtn = document.getElementById("closeBtn");
          const bomPanel = document.getElementById("bomPanel");

          mobileToggle.addEventListener("click", () => {
            this.toggleBOMPanel();
          });

          closeBtn.addEventListener("click", () => {
            this.hideBOMPanel();
          });

          // Close panel when clicking outside on mobile
          document.addEventListener("click", (e) => {
            if (
              this.isMobile &&
              this.bomPanelVisible &&
              !bomPanel.contains(e.target) &&
              !mobileToggle.contains(e.target)
            ) {
              this.hideBOMPanel();
            }
          });

          // Handle orientation change
          window.addEventListener("orientationchange", () => {
            setTimeout(() => {
              this.handleResize();
            }, 100);
          });
        }

        toggleBOMPanel() {
          this.bomPanelVisible = !this.bomPanelVisible;
          const bomPanel = document.getElementById("bomPanel");
          bomPanel.classList.toggle("mobile-visible", this.bomPanelVisible);
        }

        hideBOMPanel() {
          this.bomPanelVisible = false;
          const bomPanel = document.getElementById("bomPanel");
          bomPanel.classList.remove("mobile-visible");
        }

        showBOMPanel() {
          this.bomPanelVisible = true;
          const bomPanel = document.getElementById("bomPanel");
          bomPanel.classList.add("mobile-visible");
        }

        initThreeJS() {
          const container = document.getElementById("threejs-container");

          // Scene setup
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0xf8f9fa);

          // Camera setup
          this.camera = new THREE.PerspectiveCamera(
            75,
            container.clientWidth / container.clientHeight,
            0.1,
            1000
          );
          this.camera.position.set(15, 15, 15);

          // Renderer setup
          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
          });
          this.renderer.setSize(container.clientWidth, container.clientHeight);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for mobile performance
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          this.renderer.outputColorSpace = THREE.SRGBColorSpace;
          container.appendChild(this.renderer.domElement);

          // Controls setup with mobile optimizations
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
          );
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          this.controls.screenSpacePanning = false;
          this.controls.maxPolarAngle = Math.PI;

          // Touch-friendly controls
          this.controls.rotateSpeed = this.isMobile ? 0.8 : 1.0;
          this.controls.zoomSpeed = this.isMobile ? 0.8 : 1.2;
          this.controls.panSpeed = this.isMobile ? 0.8 : 1.0;
          this.controls.enableKeys = false; // Disable keyboard on mobile
          this.controls.touches = {
            ONE: THREE.TOUCH.ROTATE,
            TWO: THREE.TOUCH.DOLLY_PAN,
          };

          // Professional lighting setup
          const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
          this.scene.add(ambientLight);

          const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight1.position.set(20, 20, 10);
          directionalLight1.castShadow = true;
          directionalLight1.shadow.mapSize.setScalar(
            this.isMobile ? 1024 : 2048
          ); // Lower quality on mobile
          this.scene.add(directionalLight1);

          const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
          directionalLight2.position.set(-20, -10, -10);
          this.scene.add(directionalLight2);

          // Environment
          const gridHelper = new THREE.GridHelper(50, 50, 0xcccccc, 0xeeeeee);
          gridHelper.position.y = -5;
          this.scene.add(gridHelper);

          window.addEventListener("resize", () => this.handleResize());
        }

        handleResize() {
          this.isMobile = window.innerWidth <= 768;
          const container = document.getElementById("threejs-container");

          this.camera.aspect = container.clientWidth / container.clientHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(container.clientWidth, container.clientHeight);

          // Update controls for mobile/desktop
          this.controls.rotateSpeed = this.isMobile ? 0.8 : 1.0;
          this.controls.zoomSpeed = this.isMobile ? 0.8 : 1.2;
          this.controls.panSpeed = this.isMobile ? 0.8 : 1.0;
        }

        async loadAssemblyData() {
          for (const bomPath of this.bomPaths) {
            try {
              console.log(`Attempting to load assembly data from: ${bomPath}`);
              const response = await fetch(bomPath);

              if (response.ok) {
                const data = await response.json();
                this.assemblyData = data;
                this.flattenAssemblyData(data.assembly_tree || []);
                console.log(
                  "‚úÖ Successfully loaded assembly data from:",
                  bomPath
                );
                return;
              }
            } catch (error) {
              console.log(
                `Failed to load assembly data from ${bomPath}:`,
                error.message
              );
              continue;
            }
          }

          console.warn("Could not load assembly data, creating demo data");
          this.assemblyData = this.createDemoAssemblyData();
          this.flattenAssemblyData(this.assemblyData.assembly_tree);
        }

        flattenAssemblyData(tree) {
          this.flattenedParts.clear();
          let partIndex = 0;

          const traverse = (nodes) => {
            nodes.forEach((node) => {
              // Add to flattened parts with mesh index
              this.flattenedParts.set(node.id, {
                ...node,
                meshIndex: partIndex++,
              });

              if (node.children) {
                traverse(node.children);
              }
            });
          };

          traverse(tree);
          console.log(`Flattened ${this.flattenedParts.size} components`);
        }

        async loadModel() {
          const loader = new GLTFLoader();

          for (const modelPath of this.modelPaths) {
            try {
              console.log(`Attempting to load model from: ${modelPath}`);

              const gltf = await new Promise((resolve, reject) => {
                loader.load(
                  modelPath,
                  resolve,
                  (progress) => {
                    const percentComplete =
                      (progress.loaded / progress.total) * 100;
                    console.log(
                      `Loading model: ${percentComplete.toFixed(1)}%`
                    );
                  },
                  reject
                );
              });

              console.log("‚úÖ Successfully loaded model from:", modelPath);
              this.model = gltf.scene;
              this.processMeshes();
              this.centerModel();
              this.scene.add(this.model);
              document.getElementById("loadingSpinner").style.display = "none";
              return;
            } catch (error) {
              console.log(
                `Failed to load model from ${modelPath}:`,
                error.message
              );
              continue;
            }
          }

          console.warn("Could not load model, creating fallback");
          this.createFallbackModel();
        }

        processMeshes() {
          this.meshes = [];
          let meshIndex = 0;

          this.model.traverse((child) => {
            if (child.isMesh) {
              this.meshes.push(child);

              // Store original material
              if (child.material) {
                if (Array.isArray(child.material)) {
                  this.originalMaterials.set(
                    child,
                    child.material.map((mat) => mat.clone())
                  );
                } else {
                  this.originalMaterials.set(child, child.material.clone());
                }
              }

              child.castShadow = true;
              child.receiveShadow = true;
              child.userData.clickable = true;
              child.userData.meshIndex = meshIndex;
              child.userData.partName = child.name || `Mesh_${meshIndex}`;

              meshIndex++;
            }
          });

          console.log(`Processed ${this.meshes.length} meshes`);
        }

        centerModel() {
          if (!this.model) return;

          const box = new THREE.Box3().setFromObject(this.model);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());

          this.model.position.sub(center);

          const maxDim = Math.max(size.x, size.y, size.z);
          if (maxDim > 0) {
            const scale = 8 / maxDim;
            this.model.scale.multiplyScalar(scale);
          }

          const distance = maxDim > 0 ? maxDim * (this.isMobile ? 2 : 1.5) : 20;
          this.camera.position.set(distance, distance, distance);
          this.controls.target.set(0, 0, 0);
          this.controls.update();
        }

        createFallbackModel() {
          const shapes = [
            {
              geo: new THREE.BoxGeometry(3, 1, 4),
              pos: [0, 0, 0],
              color: 0x808080,
              name: "Main Assembly",
            },
            {
              geo: new THREE.CylinderGeometry(0.5, 0.5, 2),
              pos: [2, 0, 1.5],
              color: 0x404040,
              name: "Cylinder Part",
            },
            {
              geo: new THREE.BoxGeometry(1, 1, 0.5),
              pos: [-2, 1, 1],
              color: 0x606060,
              name: "Bracket",
            },
            {
              geo: new THREE.SphereGeometry(0.6),
              pos: [0, 2, -1.5],
              color: 0x707070,
              name: "Spherical Component",
            },
          ];

          shapes.forEach((shape, i) => {
            const material = new THREE.MeshPhongMaterial({
              color: shape.color,
            });
            const mesh = new THREE.Mesh(shape.geo, material);
            mesh.position.set(...shape.pos);
            mesh.userData.clickable = true;
            mesh.userData.partName = shape.name;
            mesh.userData.meshIndex = i;

            this.meshes.push(mesh);
            this.originalMaterials.set(mesh, material.clone());
            this.scene.add(mesh);
          });

          document.getElementById("loadingSpinner").style.display = "none";
        }

        createDemoAssemblyData() {
          return {
            filename: "demo_assembly.step",
            total_parts: 8,
            total_assemblies: 3,
            assembly_tree: [
              {
                name: "Main Assembly",
                id: 1,
                parent_id: null,
                type: "assembly",
                is_assembly: true,
                reference_name: "MAIN-ASSEMBLY-01",
                children: [
                  {
                    name: "Sub Assembly A",
                    id: 2,
                    parent_id: 1,
                    type: "assembly",
                    is_assembly: true,
                    reference_name: "SUB-ASSEMBLY-A-01",
                    children: [
                      {
                        name: "Part 1",
                        id: 3,
                        parent_id: 2,
                        type: "part",
                        is_assembly: false,
                        reference_name: "PART-001",
                      },
                      {
                        name: "Part 2",
                        id: 4,
                        parent_id: 2,
                        type: "part",
                        is_assembly: false,
                        reference_name: "PART-002",
                      },
                    ],
                  },
                  {
                    name: "Part 3",
                    id: 5,
                    parent_id: 1,
                    type: "part",
                    is_assembly: false,
                    reference_name: "PART-003",
                  },
                ],
              },
            ],
          };
        }

        buildAssemblyTree() {
          const bomTree = document.getElementById("bomTree");
          bomTree.innerHTML = "";

          if (!this.assemblyData || !this.assemblyData.assembly_tree) {
            bomTree.innerHTML =
              '<div class="tree-item">No assembly data available</div>';
            return;
          }

          // Update statistics
          const assemblies = Array.from(this.flattenedParts.values()).filter(
            (p) => p.is_assembly
          ).length;
          const parts = Array.from(this.flattenedParts.values()).filter(
            (p) => !p.is_assembly
          ).length;

          document.getElementById("assemblyCount").textContent = assemblies;
          document.getElementById("partCount").textContent = parts;
          document.getElementById("totalCount").textContent =
            assemblies + parts;

          // Build tree structure
          this.renderTreeNodes(this.assemblyData.assembly_tree, bomTree, 0);

          // Add fade-in animation
          bomTree.classList.add("fade-in");
        }

        renderTreeNodes(nodes, container, level) {
          nodes.forEach((node) => {
            const nodeElement = this.createTreeNode(node, level);
            container.appendChild(nodeElement);
          });
        }

        createTreeNode(node, level) {
          const nodeContainer = document.createElement("div");
          nodeContainer.className = "tree-node";

          const nodeItem = document.createElement("div");
          nodeItem.className = "tree-item";
          nodeItem.dataset.nodeId = node.id;
          nodeItem.style.paddingLeft = `${level * 16 + 8}px`;
          nodeItem.setAttribute("role", "treeitem");
          nodeItem.setAttribute(
            "aria-label",
            `${node.is_assembly ? "Assembly" : "Part"}: ${
              node.reference_name || node.name
            }`
          );

          // Touch-friendly expand button for assemblies with children
          const hasChildren = node.children && node.children.length > 0;
          if (hasChildren) {
            const expandBtn = document.createElement("button");
            expandBtn.className = "expand-button";
            expandBtn.textContent = "+";
            expandBtn.setAttribute("aria-label", "Expand/collapse");
            expandBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              this.toggleNodeExpansion(nodeContainer, expandBtn);
            });
            nodeItem.appendChild(expandBtn);
          } else {
            const spacer = document.createElement("div");
            spacer.style.width = "40px";
            nodeItem.appendChild(spacer);
          }

          // Node icon
          const icon = document.createElement("div");
          icon.className = `node-icon ${
            node.is_assembly ? "assembly-icon" : "part-icon"
          }`;
          icon.innerHTML = node.is_assembly ? "üìÅ" : "üîß";
          nodeItem.appendChild(icon);

          // Node content
          const content = document.createElement("div");
          content.className = "node-content";

          const name = document.createElement("div");
          name.className = "node-name";
          name.textContent =
            node.reference_name || node.name || `${node.type}_${node.id}`;
          content.appendChild(name);

          const details = document.createElement("div");
          details.className = "node-details";
          details.innerHTML = `
                    <span>ID: ${node.id}</span>
                    <span>${node.is_assembly ? "Assembly" : "Part"}</span>
                `;
          content.appendChild(details);

          nodeItem.appendChild(content);
          nodeContainer.appendChild(nodeItem);

          // Add children container
          if (hasChildren) {
            const childrenContainer = document.createElement("div");
            childrenContainer.className = "tree-children";
            this.renderTreeNodes(node.children, childrenContainer, level + 1);
            nodeContainer.appendChild(childrenContainer);
          }

          // Add click/touch event
          nodeItem.addEventListener("click", () => {
            this.selectNode(node);
            if (this.isMobile) {
              // Auto-hide BOM panel on mobile after selection
              setTimeout(() => this.hideBOMPanel(), 300);
            }
          });

          return nodeContainer;
        }

        toggleNodeExpansion(nodeContainer, expandBtn) {
          const childrenContainer =
            nodeContainer.querySelector(".tree-children");
          if (childrenContainer) {
            const isExpanded = childrenContainer.classList.contains("expanded");
            childrenContainer.classList.toggle("expanded");
            expandBtn.classList.toggle("expanded");
            expandBtn.textContent = isExpanded ? "+" : "-";
            expandBtn.setAttribute("aria-expanded", !isExpanded);
          }
        }

        selectNode(node, fromMeshClick = false) {
          console.log(
            `Selecting node: ${node.reference_name || node.name}, ID: ${
              node.id
            }`
          );

          this.selectedNodeId = node.id;

          // Update BOM selection
          this.updateBOMSelection(node.id);

          // Get flattened part data for mesh mapping
          const flattenedPart = this.flattenedParts.get(node.id);
          if (flattenedPart && flattenedPart.meshIndex < this.meshes.length) {
            this.selectedMeshIndex = flattenedPart.meshIndex;
            this.highlightMeshInScene(flattenedPart.meshIndex);

            if (fromMeshClick) {
              this.scrollNodeIntoView(node.id);
              if (this.isMobile) {
                this.showBOMPanel();
              }
            }
          } else {
            this.resetAllHighlights();
          }
        }

        updateBOMSelection(nodeId) {
          // Clear previous selections
          document.querySelectorAll(".tree-item").forEach((item) => {
            item.classList.remove("selected");
            item.setAttribute("aria-selected", "false");
          });

          // Highlight selected item
          const selectedItem = document.querySelector(
            `[data-node-id="${nodeId}"]`
          );
          if (selectedItem) {
            selectedItem.classList.add("selected", "highlight-animation");
            selectedItem.setAttribute("aria-selected", "true");
            setTimeout(
              () => selectedItem.classList.remove("highlight-animation"),
              800
            );
          }
        }

        scrollNodeIntoView(nodeId) {
          const selectedItem = document.querySelector(
            `[data-node-id="${nodeId}"]`
          );
          if (selectedItem) {
            selectedItem.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }
        }

        highlightMeshInScene(meshIndex) {
          this.resetAllHighlights();

          if (meshIndex < this.meshes.length) {
            const mesh = this.meshes[meshIndex];

            // Apply highlight material
            if (Array.isArray(mesh.material)) {
              mesh.material = mesh.material.map(() =>
                this.highlightMaterial.clone()
              );
            } else {
              mesh.material = this.highlightMaterial.clone();
            }

            this.focusCameraOnMesh(mesh);
          }
        }

        resetAllHighlights() {
          this.meshes.forEach((mesh) => {
            if (this.originalMaterials.has(mesh)) {
              const originalMaterial = this.originalMaterials.get(mesh);

              if (Array.isArray(originalMaterial)) {
                mesh.material = originalMaterial.map((mat) => {
                  const cloned = mat.clone();
                  if (this.isWireframe) cloned.wireframe = true;
                  return cloned;
                });
              } else {
                mesh.material = originalMaterial.clone();
                if (this.isWireframe) mesh.material.wireframe = true;
              }
            }
          });
        }

        focusCameraOnMesh(mesh) {
          const box = new THREE.Box3().setFromObject(mesh);
          const center = box.getCenter(new THREE.Vector3());

          this.controls.target.copy(center);
          this.controls.update();
        }

        setupEventListeners() {
          // Search functionality
          const searchBox = document.getElementById("searchBox");
          searchBox.addEventListener("input", (e) =>
            this.filterNodes(e.target.value)
          );

          // 3D mesh click detection
          this.renderer.domElement.addEventListener("click", (event) =>
            this.onMeshClick(event)
          );

          // Double-click to deselect
          this.renderer.domElement.addEventListener("dblclick", () =>
            this.deselectAll()
          );

          // Prevent context menu on long touch
          this.renderer.domElement.addEventListener("contextmenu", (e) =>
            e.preventDefault()
          );
        }

        onMeshClick(event) {
          const mouse = new THREE.Vector2();
          const rect = this.renderer.domElement.getBoundingClientRect();

          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, this.camera);

          const intersects = raycaster.intersectObjects(this.meshes, false);

          if (intersects.length > 0) {
            const clickedMesh = intersects[0].object;
            const meshIndex = clickedMesh.userData.meshIndex;

            // Find corresponding assembly node by mesh index
            for (const [nodeId, part] of this.flattenedParts.entries()) {
              if (part.meshIndex === meshIndex) {
                this.selectNode(part, true);
                return;
              }
            }

            console.warn(`No assembly node found for mesh index: ${meshIndex}`);
          }
        }

        deselectAll() {
          this.selectedNodeId = null;
          this.selectedMeshIndex = null;

          document.querySelectorAll(".tree-item").forEach((item) => {
            item.classList.remove("selected");
            item.setAttribute("aria-selected", "false");
          });

          this.resetAllHighlights();
        }

        filterNodes(searchTerm) {
          const nodes = document.querySelectorAll(".tree-item");
          searchTerm = searchTerm.toLowerCase();

          nodes.forEach((node) => {
            const text = node.textContent.toLowerCase();
            const parentNode = node.closest(".tree-node");
            parentNode.style.display = text.includes(searchTerm)
              ? "block"
              : "none";
          });
        }

        // Control methods
        toggleWireframe() {
          this.isWireframe = !this.isWireframe;
          const btn = document.getElementById("wireframeBtn");

          this.meshes.forEach((mesh) => {
            if (Array.isArray(mesh.material)) {
              mesh.material.forEach(
                (mat) => (mat.wireframe = this.isWireframe)
              );
            } else {
              mesh.material.wireframe = this.isWireframe;
            }
          });

          btn.classList.toggle("active", this.isWireframe);
        }

        toggleBoundingBoxes() {
          this.showBoundingBoxes = !this.showBoundingBoxes;
          const btn = document.getElementById("boundingBoxBtn");

          if (this.showBoundingBoxes) {
            this.createBoundingBoxes();
          } else {
            this.removeBoundingBoxes();
          }

          btn.classList.toggle("active", this.showBoundingBoxes);
        }

        createBoundingBoxes() {
          this.meshes.forEach((mesh) => {
            const helper = new THREE.BoxHelper(mesh, 0xffd700);
            this.boundingBoxHelpers.push(helper);
            this.scene.add(helper);
          });
        }

        removeBoundingBoxes() {
          this.boundingBoxHelpers.forEach((helper) => {
            this.scene.remove(helper);
          });
          this.boundingBoxHelpers = [];
        }

        resetCamera() {
          if (this.model) {
            this.centerModel();
          } else {
            this.camera.position.set(15, 15, 15);
            this.controls.target.set(0, 0, 0);
          }
          this.controls.update();
        }

        toggleAutoRotate() {
          this.isAutoRotating = !this.isAutoRotating;
          this.controls.autoRotate = this.isAutoRotating;
          this.controls.autoRotateSpeed = 0.5;
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          this.controls.update();

          if (this.showBoundingBoxes) {
            this.boundingBoxHelpers.forEach((helper) => helper.update());
          }

          this.renderer.render(this.scene, this.camera);
        }
      }

      // Global control functions
      window.resetCamera = () => window.bomViewer?.resetCamera();
      window.toggleWireframe = () => window.bomViewer?.toggleWireframe();
      window.toggleBoundingBoxes = () =>
        window.bomViewer?.toggleBoundingBoxes();
      window.toggleAutoRotate = () => window.bomViewer?.toggleAutoRotate();

      // Initialize application
      document.addEventListener("DOMContentLoaded", () => {
        window.bomViewer = new ProfessionalBOMViewer();
      });
    </script>
  </body>
</html>
